
One important aspect of your script is the ability to have custom nodes. Not all scripts can solely rely on the core set of nodes provided for you by wcPlay. For this, custom nodes can be developed for use in your scripts. Custom nodes are written directly in JavaScript and included into your page via the `<script>` tag.

```
wcNodeProcess.extend('wcNodeProcessDelay', 'Delay', 'Core', {
  /**
   * @class
   * Waits for a specified amount of time before continuing the flow chain.<br>
   * When inheriting, make sure to include 'this._super(parent, pos);' at the top of your init function.
   *
   * @constructor wcNodeProcessDelay
   * @param {String} parent - The parent object of this node.
   * @param {wcPlay~Coordinates} pos - The position of this node in the visual editor.
   */
  init: function(parent, pos) {
    this._super(parent, pos);

    this.description("Waits for a specified amount of time before continuing the flow chain.");

    // Create the message property so we know what to output in the log.
    this.createProperty('milliseconds', wcPlay.PROPERTY.NUMBER, 1000, {description: "The time delay, in milliseconds, to wait before firing the 'out' Exit link."});
  },

  /**
   * Event that is called when an entry link has been triggered.<br>
   * Overload this in inherited nodes, be sure to call 'this._super(..)' at the top.
   * @function wcNodeProcessDelay#onTriggered
   * @param {String} name - The name of the entry link triggered.
   */
  onTriggered: function(name) {
    this._super(name);

    // Now set a timeout to wait for 'Milliseconds' amount of time.    
    var delay = this.property('milliseconds');

    // Start a timeout event using the node's built in timeout handler.
    this.setTimeout(function() {
      this.activateExit('out');
    }, delay);
  },
});
```

****
### Extending a Node Class ###

To program your own node, use the `extend` function on any base node class. Base node classes are either `wcNodeEntry`, `wcNodeProcess`, or `wcNodeStorage` depending on what type of node you want to make.
- Entry nodes generally begin chains, they listen for specific events and activate themselves whenever those conditions pass.
- Process nodes make up the bulk of your script, these nodes are designed to perform an action whenever they are activated through an Entry link, and then continue the script by activating an Exit link.
- Storage nodes are very simply a node that just stores a property value.

The extend function takes a number of parameters explained [here]{@link wcNode#extend}.


****
### Setting up Properties and Links ###

Once you have extended your new node class, you will want to implement the `init` function first, this is your constructor where all your [Entry]{@link wcNode#createEntry}, [Exit]{@link wcNode#createExit}, and [Property]{@link wcNode#createProperty} setup should be.

By default, all nodes have an 'enabled' property, all `Entry` nodes have an 'out' Exit link, and all `Process` nodes have an 'in' Entry link and an 'out' Exit link.

You should never remove the 'enabled' property, as doing so will permenently disable your node. However, the default Entry and Exit links can be removed via the {@link wcNode#removeEntry} and {@link wcNode#removeExit} functions.


****
### Overloading Event Functions ###

In many cases, you will need to catch events as they happen on your node. For this, {@link wcNode} provides many event functions that you can overload. All event functions begin with 'on' in their name, such as [onTriggered]{@link wcNode#onTriggered}. There are many more event hooks to use, to see a listing, view the [documentation]{@link wcNode}.


****
### Latent Nodes ###

In cases where your node may take time to perform an action, a threading system is provided for you. This allows the script to keep track of any timeout, or latent, events being processed on a node so it may have a better sense of what nodes are active, as well as a method for cancelling node operations if necessary.

There are a few ways to implement a latent node:
 - The recommended method is shown in the example code above, it uses a special [wcNode.setTimeout]{@link wcNode#setTimeout} function in place of the global `window.setTimeout`. The reason this is recommended, is the actual timeout is handled internally so it can be paused, resumed, and even canceled by the script if necessary. This allows the live debugger to more accurately step a node by only a specified amount of time. Also provided is the [wcNode.setInterval]{@link wcNode#setInterval} which should replace any call to the global `window.setInterval`.
 - For AJAX requests, [wcNode.ajax]{@link wcNode#ajax} is provided as a wrapper for jQuery's AJAX functionality. Again, it is recommended that you run ajax commands through this method as it is better equipped for the live debugger.
 - Alternatively, you can use the global `window.setTimeout` and `window.setInterval` functions, with a slight alteration. The resulting ID of the timer function should be sent to {@link wcNode#beginThread} when started, and again to {@link wcNode#finishThread} when the timed event is finished. Although the system supports these, it is not recommended as the live debugger has limited control which will cause a less accurate debugging experience.
 - The final method for implementing a latent node is through a custom cancellation function. This is the worst and most complicated way to do it, but is provided in those cases where it becomes necessary, such as through an AJAX request or when using Promise events. To do this, perform your AJAX or Promise as normal, except you also need to provide a callback function that can be called to cancel, or ignore, the resulting event when it comes in. `In the future, I plan to do the same as I do with {@link wcNode#setTimeout} and provide you with custom methods that can be better handled.`


****
Return to the {@tutorial 3.0} tutorial.  
Continue to the {@tutorial 5.0} tutorial.  